#
#  Automata Programming Assignment #2
#
#  Name:  권수민
#  ID: 20225010
#

import sys
import copy
# Do not import any other libraries


def is_variable(value):
    """
    Upper case letters are variables.
    :param value: Node value.
    :return: True or False.
    """
    return value.isupper()


def is_terminal(value):
    """
    Lower case letters are terminal symbols.
    :param value: Node Value.
    :return: True or False.
    """
    return value.islower()


class DerivationTree:
    def __init__(self, value, children=[]):
        """
        :param root_value: Root value of derivation tree. An English letter, upper case or lower case.
        :param children: A list of child nodes of root.
        """
        self.value = value
        self.children = children

    def print_tree(self, height=[]):
        """
        Do not modify this function!
        Just use it when you want to print out the tree.
        """
        height_level = len(height)
        tab_str = "|  "
        branch = "".join(map(lambda x: tab_str if x else "   ", height[:-1]))
        branch += "+--" if height_level > 0 else ""

        print(branch, self.value, sep='')
        for i, child in enumerate(self.children):
            isterminal = i == len(self.children) - 1
            child.print_tree([*height, not isterminal])

    def string(self):
        """
        :return: String made of terminal nodes of derivation tree.
        """
        # Write your code here. e.g.
        # str = "Aab"
        # return str
        result= ""
        n=len(self.children)
        if n==0:
            return self.value
        else:
            for child in self.children:
                result+=child.string()
        return result
    
    def length(self):
        """
        :return: Length of terminal nodes of derivation tree (not variables).
        """
        # Write your code here. e.g.
        # l = 2
        # return l
        n=0
        for symbol in self.string():
            n+= int(is_terminal(symbol))
        return n

class CFG:
    def __init__(self, filename):
        # Production rules are stored in dictionary form.
        self.rules = {}
        with open(filename, "r") as fp1:
            lines = fp1.readlines()
            for line in lines:
                content = line.split()
                left = content[0]
                for right in content[1:]:
                    if right == '|' or right == '>':
                        continue
                    if self.rules.get(left) is None:
                        self.rules[left] = {right}

                    else:
                        self.rules[left].add(right)

    def make_child(self, tree):
        """
        :param tree: Derivation tree.
        :return l: list of derivation trees after only one leftmost variable production
        :return done: just check you have done production, necessary for recursion
                    if you don't use it, erase it.
        """
        # Write your code here. e.g.
        # l = [DerivationTree("S"), DerivationTree("A")]
        # done = True
        # return l, done

        l = []
        done = False
        
        if len(tree.children) == 0:
            if tree.value in self.rules:
                sub = []
                for rule in self.rules[tree.value]:
                    now = copy.deepcopy(tree)
                    now.children = [DerivationTree(a) for a in rule]
                    sub.append(now)
                return sub, True
            else:
                return [], False
                
        else:
            for i, child in enumerate(tree.children):
                sub, done = self.make_child(child)
                if done:
                    for s in sub:
                        now = copy.deepcopy(tree)
                        now.children[i] = s
                        l.append(now)
                    break
            return l, done

    def make_string(self, l = 0):
        """
        :param l: length of string.
        :return: List of tree with string length l that can be generated by CFG
        """
        # Write your code here. e.g.
        # l = [DerivationTree("S"), DerivationTree("A")]
        # return l
        temp = []
        result = []
        
        def tree_list(tree, l, depth):
            if len(tree.string()) == tree.length() == l:
                temp.append(tree.string())
            else:
                if tree.length() < l:
                    new_tree, _ = self.make_child(tree)
                    for t in new_tree:
                        if t.length() <= l:
                            tree_list(t, l, depth + 1)
                        else:
                            pass
                else:
                    pass
        
        for root in list(self.rules.keys()):
            tree_list(DerivationTree(root), l, 0)
        
        for string in temp:
            if string not in result:
                result.append(string)
                
        return result
    
    def ambiguous_checker(self):
        """
        Just check the ambiguity only for strings of length 10 or less.
        :return: True if ambiguous. False if not ambiguous.
        """
        # Write your code here. e.g.
        # ambiguous = True
        # return ambiguous
        temp = []
        result = []
        ambiguous = False
        
        def tree_list(tree, length, depth):
            if len(tree.string()) == tree.length():
                temp.append(tree.string())
            else:
                if tree.length() < length:
                    new_tree, _ = self.make_child(tree)
                    for t in new_tree:
                        if t.length() <= length:
                            tree_list(t, length, depth + 1)
                        else:
                            pass
                else:
                    pass
        
        for root in list(self.rules.keys()):
            tree_list(DerivationTree(root), 10, 0)

        for string in temp:
            if string not in result:
                result.append(string)
            else:
                ambiguous = True
                return ambiguous
        
        return False



def test(*args):
    """
    If you want to debug your code, use the test function.
    This confirms only one case, so even if you pass the test function, you may not get a perfect score.
    """
    if len(args) < 2:
        raise ValueError("Not enough arguments")

    filename = args[1]

    # Test for string and length in DerivationTree
    a = DerivationTree('a')
    b = DerivationTree('b')
    AA = DerivationTree('A')
    B = DerivationTree('B')
    A = DerivationTree('A')
    S = DerivationTree('S')
    B.children = [b]
    A.children = [AA, a]
    S.children = [A, B]
    print(A.children, B.children)
    if S.string() != "Aab":
        raise ValueError("I do pIncorrect string function")
    else:
        print("Success String")
    if S.length() != 2:
        raise ValueError("Incorrect length function")
    else:
        print("Success Length")

    # Test for make_child in CFG
    Q = CFG(filename)
    B = DerivationTree('B')
    A = DerivationTree('A')
    S = DerivationTree('S')
    S.children = [A, B]
    tree_list, _ = Q.make_child(S)
    str_list = []
    for tree in tree_list:
        str_list.append(tree.string())
    str_list.sort()
    if str_list != ["AaB", "aB"]:
        raise ValueError("Incorrect make_child function")
    else:
        print("Success make_child")

    # Test for make_string in CFG
    make_list = Q.make_string(4)
    if len(make_list) != 2:
        raise ValueError("Incorrect make_string function")
    else:
        print("Success make_string")

    # Test for ambiguous_checker in CFG
    if not Q.ambiguous_checker():
        raise ValueError("Incorrect ambiguous_checker function")
    else:
        print("Success ambiguous_checker")


if __name__ == '__main__':
    args = sys.argv
    test(*args)