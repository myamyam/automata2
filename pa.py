#
#  Automata Programming Assignment #2
#
#  Name:  권수민
#  ID: 20225010
#

import sys
import copy
# Do not import any other libraries


def is_variable(value):
    """
    Upper case letters are variables.
    :param value: Node value.
    :return: True or False.
    """
    return value.isupper()


def is_terminal(value):
    """
    Lower case letters are terminal symbols.
    :param value: Node Value.
    :return: True or False.
    """
    return value.islower()


class DerivationTree:
    def __init__(self, value, children=[]):
        """
        :param root_value: Root value of derivation tree. An English letter, upper case or lower case.
        :param children: A list of child nodes of root.
        """
        self.value = value
        self.children = children

    def print_tree(self, height=[]):
        """
        Do not modify this function!
        Just use it when you want to print out the tree.
        """
        height_level = len(height)
        tab_str = "|  "
        branch = "".join(map(lambda x: tab_str if x else "   ", height[:-1]))
        branch += "+--" if height_level > 0 else ""

        print(branch, self.value, sep='')
        for i, child in enumerate(self.children):
            isterminal = i == len(self.children) - 1
            child.print_tree([*height, not isterminal])

    def string(self):
        """
        :return: String made of terminal nodes of derivation tree.
        """
        # Write your code here. e.g.
        # str = "Aab"
        # return str
        if is_terminal(self.value):
            return self.value
        result = ""
        for child in self.children:
            result += child.string()
        return result
        
    def length(self):
        """
        :return: Length of terminal nodes of derivation tree (not variables).
        """
        # Write your code here. e.g.
        # l = 2
        # return l
        if is_terminal(self.value):
            return 1
        length = 0
        for child in self.children:
            length += child.length()
        return length


class CFG:
    def __init__(self, filename):
        # Production rules are stored in dictionary form.
        self.rules = {}
        with open(filename, "r") as fp1:
            lines = fp1.readlines()
            for line in lines:
                content = line.split()
                left = content[0]
                for right in content[1:]:
                    if right == '|' or right == '>':
                        continue
                    if self.rules.get(left) is None:
                        self.rules[left] = {right}

                    else:
                        self.rules[left].add(right)

    def make_child(self, tree):
        """
        :param tree: Derivation tree.
        :return l: list of derivation trees after only one leftmost variable production
        :return done: just check you have done production, necessary for recursion
                    if you don't use it, erase it.
        """
        # Write your code here. e.g.
        # l = [DerivationTree("S"), DerivationTree("A")]
        # done = True
        # return l, done
        if is_terminal(tree.value):
            return [tree], False
        
        children = []
        done = False
        for child in tree.children:
            if is_variable(child.value) and not done:
                for production in self.rules[child.value]:
                    new_children = [DerivationTree(c) for c in production]
                    new_tree = DerivationTree(tree.value, tree.children[:])
                    new_tree.children = tree.children[:]
                    new_tree.children[new_tree.children.index(child)] = DerivationTree(child.value, new_children)
                    children.append(new_tree)
                done = True
            else:
                new_child, _ = self.make_child(child)
                children.append(new_child)
                
        return children, done


    def make_string(self, l = 0):
        """
        :param l: length of string.
        :return: List of tree with string length l that can be generated by CFG
        """
        # Write your code here. e.g.
        # l = [DerivationTree("S"), DerivationTree("A")]
        # return l
        trees = [DerivationTree("S")]
        while True:
            new_trees = []
            for tree in trees:
                if tree.length() == l:
                    new_trees.append(tree)
                elif tree.length() < l:
                    children, _ = self.make_child(tree)
                    new_trees.extend(children)
            if not new_trees:
                break
            trees = new_trees
        return [tree for tree in trees if tree.length() == l]

    def ambiguous_checker(self):
        """
        Just check the ambiguity only for strings of length 10 or less.
        :return: True if ambiguous. False if not ambiguous.
        """
        # Write your code here. e.g.
        # ambiguous = True
        # return ambiguous
        seen_strings = {}
        for length in range(1, 11):
            trees = self.make_string(length)
            for tree in trees:
                s = tree.string()
                if s in seen_strings:
                    return True
                seen_strings[s] = tree
        return False


def test(*args):
    """
    If you want to debug your code, use the test function.
    This confirms only one case, so even if you pass the test function, you may not get a perfect score.
    """
    if len(args) < 2:
        raise ValueError("Not enough arguments")

    filename = args[1]

    # Test for string and length in DerivationTree
    a = DerivationTree('a')
    b = DerivationTree('b')
    AA = DerivationTree('A')
    B = DerivationTree('B')
    A = DerivationTree('A')
    S = DerivationTree('S')
    B.children = [b]
    A.children = [AA, a]
    S.children = [A, B]
    print(A.children, B.children)
    if S.string() != "Aab":
        raise ValueError("I do pIncorrect string function")
    else:
        print("Success String")
    if S.length() != 2:
        raise ValueError("Incorrect length function")
    else:
        print("Success Length")

    # Test for make_child in CFG
    Q = CFG(filename)
    B = DerivationTree('B')
    A = DerivationTree('A')
    S = DerivationTree('S')
    S.children = [A, B]
    tree_list, _ = Q.make_child(S)
    str_list = []
    for tree in tree_list:
        str_list.append(tree.string())
    str_list.sort()
    if str_list != ["AaB", "aB"]:
        raise ValueError("Incorrect make_child function")
    else:
        print("Success make_child")

    # Test for make_string in CFG
    make_list = Q.make_string(4)
    if len(make_list) != 2:
        raise ValueError("Incorrect make_string function")
    else:
        print("Success make_string")

    # Test for ambiguous_checker in CFG
    if not Q.ambiguous_checker():
        raise ValueError("Incorrect ambiguous_checker function")
    else:
        print("Success ambiguous_checker")


if __name__ == '__main__':
    args = sys.argv
    test(*args)